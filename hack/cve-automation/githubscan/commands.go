package githubscan

import (
	"fmt"
	"sync/atomic"
	"time"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/nginx/kubernetes-ingress/hack/cve-automation/githubartifacts"
	"github.com/nginx/kubernetes-ingress/hack/cve-automation/reporter"
)

const maxInt32 = 1<<31 - 1

// artifactDownloadProgressMsg is sent as progress updates during artifact download
type artifactDownloadProgressMsg struct {
	message      string
	artifactName string
	completed    bool
	inProgress   bool
	progress     float64
	ch           chan tea.Msg
}

// artifactDownloadCompleteMsg is sent when artifact download completes
type artifactDownloadCompleteMsg struct {
	outputDir    string
	randomSuffix string
	err          error
}

// parseCompleteMsg is sent when parsing and rendering completes
type parseCompleteMsg struct {
	reportPath string
	err        error
}

// downloadArtifacts downloads artifacts for the selected branch
func downloadArtifacts(branch string) tea.Cmd {
	return func() tea.Msg {
		msgChan := make(chan tea.Msg, 100)

		go func() {
			defer close(msgChan)

			token, err := githubartifacts.GetToken()
			if err != nil {
				msgChan <- artifactDownloadCompleteMsg{err: fmt.Errorf("getting GitHub token: %w", err)}
				return
			}

			msgChan <- artifactDownloadProgressMsg{
				message:  fmt.Sprintf("Fetching artifacts for branch %s...", branch),
				progress: 0.0,
				ch:       msgChan,
			}

			artifacts, err := githubartifacts.GetArtifactURLs(token, branch)
			if err != nil {
				msgChan <- artifactDownloadCompleteMsg{err: fmt.Errorf("getting artifact URLs: %w", err)}
				return
			}

			if len(artifacts) == 0 {
				msgChan <- artifactDownloadCompleteMsg{err: fmt.Errorf("no artifacts found for branch %s", branch)}
				return
			}

			msgChan <- artifactDownloadProgressMsg{
				message:  fmt.Sprintf("Found %d artifacts, downloading...", len(artifacts)),
				progress: 0.0,
				ch:       msgChan,
			}

			// Initialize all artifacts as pending
			for _, artifact := range artifacts {
				msgChan <- artifactDownloadProgressMsg{
					message:      fmt.Sprintf("Queued %s", artifact.Name),
					artifactName: artifact.Name,
					completed:    false,
					inProgress:   false,
					progress:     0.0,
					ch:           msgChan,
				}
			}

			// Give UI time to render the list before starting downloads
			time.Sleep(200 * time.Millisecond)

			var completed atomic.Int32

			if len(artifacts) > maxInt32 {
				msgChan <- artifactDownloadCompleteMsg{err: fmt.Errorf("too many artifacts to download: %d (max %d)", len(artifacts), maxInt32)}
				return
			}

			total := int32(len(artifacts)) //gosec:disable G115 -- len(artifacts) is not user input, it's from GitHub API response. It's never going to be larger than int32 max.

			// Download artifacts with progress callback
			baseDir := "."
			outputDir, suffix, err := githubartifacts.DownloadArtifacts(artifacts, baseDir, func(name string, inProgress, done bool) {
				count := completed.Load()
				if done {
					count = completed.Add(1)
				}
				msgChan <- artifactDownloadProgressMsg{
					message:      fmt.Sprintf("Downloading %s...", name),
					artifactName: name,
					inProgress:   inProgress,
					completed:    done,
					progress:     float64(count) / float64(total),
					ch:           msgChan,
				}
			})
			if err != nil {
				msgChan <- artifactDownloadCompleteMsg{err: fmt.Errorf("downloading artifacts: %w", err)}
				return
			}

			msgChan <- artifactDownloadCompleteMsg{outputDir: outputDir, randomSuffix: suffix, err: nil}
		}()

		return waitForMessages(msgChan)
	}
}

// parseAndRenderReport parses selected SARIF files and generates a markdown report
func parseAndRenderReport(suffix string, selectedSarifs map[string]struct{}) tea.Cmd {
	return func() tea.Msg {
		vulns, err := reporter.ParseSarifFiles(selectedSarifs)
		if err != nil {
			return parseCompleteMsg{err: fmt.Errorf("parsing SARIF files: %w", err)}
		}

		baseDir := "."
		reportPath, err := reporter.RenderMarkdown(vulns, baseDir, suffix)
		if err != nil {
			return parseCompleteMsg{err: fmt.Errorf("rendering report: %w", err)}
		}

		return parseCompleteMsg{reportPath: reportPath, err: nil}
	}
}

// waitForMessages reads from the channel and returns the first message
func waitForMessages(ch chan tea.Msg) tea.Msg {
	return <-ch
}

// continueWaitingForMessages is a Cmd that continues reading from the channel
func continueWaitingForMessages(ch chan tea.Msg) tea.Cmd {
	return func() tea.Msg {
		msg, ok := <-ch
		if !ok {
			return nil
		}
		return msg
	}
}
