package githubscan

import (
	"fmt"
	"os"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/list"
	"github.com/charmbracelet/bubbles/progress"
	"github.com/charmbracelet/bubbles/spinner"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/nginx/kubernetes-ingress/hack/cve-automation/ui"
)

// ConfirmChoice represents the user's confirmation selection
type confirmChoice int

const (
	confirmNo confirmChoice = iota
	confirmYes
)

// Update handles all state updates and message processing
//
//nolint:gocyclo // This function is inherently complex due to the number of states and messages it needs to handle, but we can refactor it later if needed
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.windowWidth = msg.Width
		m.windowHeight = msg.Height

		if m.branchList.Items() != nil {
			m.branchList.SetSize(msg.Width-4, msg.Height-8)
		}
		if m.sarifList.Items() != nil {
			m.sarifList.SetSize(msg.Width-4, msg.Height-6)
		}

		return m, nil

	case tea.KeyMsg:
		if key.Matches(msg, m.keys.quit) && m.state != stepFetchingArtifacts && m.state != stepParseAndRender {
			return m, tea.Quit
		}

		switch m.state {
		case stepSelectBranch:
			return m.handleBranchSelection(msg)
		case stepSelectSarifFiles:
			return m.handleSarifSelection(msg)
		case stepConfirmSelection:
			return m.handleConfirmation(msg)
		case stepAskCleanup:
			return m.handleCleanup(msg)
		case stepComplete:
			if key.Matches(msg, m.keys.enter) || key.Matches(msg, m.keys.quit) {
				return m, tea.Quit
			}
		}

	case branchListMsg:
		if msg.err != nil {
			m.err = msg.err
			m.state = stepComplete
			return m, nil
		}

		m.branches = msg.branches
		items := make([]list.Item, len(msg.branches))
		for i, branch := range msg.branches {
			items[i] = branchItem{name: branch}
		}

		delegate := list.NewDefaultDelegate()
		m.branchList = list.New(items, delegate, m.windowWidth-4, m.windowHeight-10)
		m.branchList.Title = "Select a branch"
		m.branchList.SetShowStatusBar(false)
		m.branchList.SetFilteringEnabled(false)

		return m, nil

	case artifactDownloadProgressMsg:
		m.progressMessage = msg.message
		if msg.artifactName != "" {
			if msg.completed {
				m.artifactStatuses[msg.artifactName] = statusDone
			} else if msg.inProgress {
				m.artifactStatuses[msg.artifactName] = statusInProgress
			} else {
				// Initialize as pending
				m.artifactStatuses[msg.artifactName] = statusPending
			}
		}
		m.downloadProgress = msg.progress

		if msg.ch != nil {
			return m, continueWaitingForMessages(msg.ch)
		}
		return m, nil

	case artifactDownloadCompleteMsg:
		if msg.err != nil {
			m.err = msg.err
			m.state = stepComplete
			return m, nil
		}

		m.outputDir = msg.outputDir
		m.randomSuffix = msg.randomSuffix
		m.tempDirToCleanup = msg.outputDir

		files, err := ui.LoadSarifFilesList(msg.outputDir)
		if err != nil {
			m.err = fmt.Errorf("loading SARIF files: %w", err)
			m.state = stepComplete
			return m, nil
		}

		delegate := ui.NewSelectDelegate(&m.selectedSarifs)
		m.sarifList = list.New(files, delegate, m.windowWidth-4, m.windowHeight-6)
		m.sarifList.Title = "Select SARIF files to include in report"
		m.sarifList.SetShowStatusBar(true)
		m.sarifList.SetFilteringEnabled(false)

		m.state = stepSelectSarifFiles
		return m, nil

	case parseCompleteMsg:
		if msg.err != nil {
			m.err = msg.err
		} else {
			m.reportPath = msg.reportPath
		}
		m.state = stepAskCleanup
		return m, nil

	case spinner.TickMsg:
		var cmd tea.Cmd
		m.spinner, cmd = m.spinner.Update(msg)
		return m, cmd

	case progress.FrameMsg:
		progressModel, cmd := m.prog.Update(msg)
		m.prog = progressModel.(progress.Model)
		return m, cmd
	}

	return m, tea.Batch(cmds...)
}

// handleBranchSelection handles branch selection input
func (m Model) handleBranchSelection(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch {
	case key.Matches(msg, m.keys.enter):
		if item, ok := m.branchList.SelectedItem().(branchItem); ok {
			m.selectedBranch = item.name
			m.state = stepFetchingArtifacts
			m.progressMessage = fmt.Sprintf("Fetching artifacts for %s...", item.name)
			return m, tea.Batch(
				m.spinner.Tick,
				downloadArtifacts(item.name),
			)
		}
		return m, nil

	default:
		var cmd tea.Cmd
		m.branchList, cmd = m.branchList.Update(msg)
		return m, cmd
	}
}

// handleSarifSelection handles SARIF file selection input
func (m Model) handleSarifSelection(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch {
	case key.Matches(msg, m.keys.selectAll):
		// Select all SARIF files
		for _, item := range m.sarifList.Items() {
			sarif := item.(ui.SarifFile)
			m.selectedSarifs[sarif.Path] = struct{}{}
		}
		return m, nil

	case key.Matches(msg, m.keys.space):
		if item, ok := m.sarifList.SelectedItem().(ui.SarifFile); ok {
			if _, exists := m.selectedSarifs[item.Path]; exists {
				delete(m.selectedSarifs, item.Path)
			} else {
				m.selectedSarifs[item.Path] = struct{}{}
			}
		}
		return m, nil

	case key.Matches(msg, m.keys.enter):
		if len(m.selectedSarifs) == 0 {
			return m, nil
		}
		m.state = stepConfirmSelection
		m.confirmationChoice = confirmNo
		return m, nil

	default:
		var cmd tea.Cmd
		m.sarifList, cmd = m.sarifList.Update(msg)
		return m, cmd
	}
}

// handleConfirmation handles confirmation screen input
func (m Model) handleConfirmation(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch {
	case key.Matches(msg, m.keys.left), key.Matches(msg, m.keys.right), key.Matches(msg, m.keys.tab):
		if m.confirmationChoice == confirmYes {
			m.confirmationChoice = confirmNo
		} else {
			m.confirmationChoice = confirmYes
		}
		return m, nil

	case key.Matches(msg, m.keys.enter):
		if m.confirmationChoice == confirmNo {
			return m, tea.Quit
		}
		m.state = stepParseAndRender
		m.progressMessage = "Parsing SARIF files and generating report..."
		return m, tea.Batch(
			m.spinner.Tick,
			parseAndRenderReport(m.randomSuffix, m.selectedSarifs),
		)
	}

	return m, nil
}

// handleCleanup handles cleanup confirmation input
func (m Model) handleCleanup(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch {
	case key.Matches(msg, m.keys.left), key.Matches(msg, m.keys.right), key.Matches(msg, m.keys.tab):
		if m.cleanupChoice == confirmYes {
			m.cleanupChoice = confirmNo
		} else {
			m.cleanupChoice = confirmYes
		}
		return m, nil

	case key.Matches(msg, m.keys.enter):
		if m.cleanupChoice == confirmYes {
			if m.tempDirToCleanup != "" {
				if err := os.RemoveAll(m.tempDirToCleanup); err != nil {
					m.err = fmt.Errorf("deleting temp directory: %w", err)
				}
			}
		}
		m.state = stepComplete
		return m, nil
	}

	return m, nil
}
