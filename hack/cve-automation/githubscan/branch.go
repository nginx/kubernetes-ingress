package githubscan

import (
	"context"
	"fmt"
	"sort"
	"strconv"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/google/go-github/v82/github"
	"github.com/nginx/kubernetes-ingress/hack/cve-automation/githubartifacts"
	"golang.org/x/oauth2"
)

// branchListMsg contains the list of fetched branches
type branchListMsg struct {
	branches []string
	err      error
}

// fetchBranches retrieves all release-* branches from GitHub
func fetchBranches() tea.Cmd {
	return func() tea.Msg {
		token, err := githubartifacts.GetToken()
		if err != nil {
			return branchListMsg{err: fmt.Errorf("getting GitHub token: %w", err)}
		}

		ctx := context.Background()
		tokenSource := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: token})
		oauth2Client := oauth2.NewClient(ctx, tokenSource)
		client := github.NewClient(oauth2Client)

		// List all branches
		branches, _, err := client.Repositories.ListBranches(ctx, githubartifacts.Owner, githubartifacts.Repo, &github.BranchListOptions{
			ListOptions: github.ListOptions{
				PerPage: 100,
			},
		})
		if err != nil {
			return branchListMsg{err: fmt.Errorf("listing branches: %w", err)}
		}

		// Filter and parse release branches
		var releaseBranches []string
		for _, branch := range branches {
			name := branch.GetName()
			if strings.HasPrefix(name, "release-") {
				releaseBranches = append(releaseBranches, name)
			}
		}

		// Sort by semantic version (descending)
		sortedBranches := sortReleasesBranches(releaseBranches)

		// Take main and the most recent release branch only
		topBranches := []string{"main"}
		if len(sortedBranches) > 0 {
			topBranches = append(topBranches, sortedBranches[0])
		}

		return branchListMsg{branches: topBranches}
	}
}

// sortReleasesBranches sorts release branches by semantic version in descending order
func sortReleasesBranches(branches []string) []string {
	type versionInfo struct {
		branch string
		major  int
		minor  int
	}

	versions := make([]versionInfo, 0, len(branches))

	for _, branch := range branches {
		version := strings.TrimPrefix(branch, "release-")
		parts := strings.Split(version, ".")

		if len(parts) != 2 {
			continue
		}

		major, err1 := strconv.Atoi(parts[0])
		minor, err2 := strconv.Atoi(parts[1])

		if err1 != nil || err2 != nil {
			continue
		}

		versions = append(versions, versionInfo{
			branch: branch,
			major:  major,
			minor:  minor,
		})
	}

	sort.Slice(versions, func(i, j int) bool {
		if versions[i].major != versions[j].major {
			return versions[i].major > versions[j].major
		}
		return versions[i].minor > versions[j].minor
	})

	sorted := make([]string, len(versions))
	for i, v := range versions {
		sorted[i] = v.branch
	}

	return sorted
}
