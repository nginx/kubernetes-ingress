package main

import (
	"context"
	"fmt"
	"time"

	"github.com/moby/moby/client"
)

const (
	getImagesTimeout = 20 * time.Second
	filterNGINX      = "nginx/*"
)

type model struct {
	filter   string
	images   []image
	selected []string
}

type image struct {
	size string
	id   string
	tags []string
}

func initialModel() (model, error) {
	images, err := getImagesWithFilter(filterNGINX)
	if err != nil {
		return model{}, fmt.Errorf("could not get images with filter %q: %w", filterNGINX, err)
	}

	return model{
		filter: filterNGINX,
		// Our to-do list is a grocery list
		images: images,

		// A map which indicates which choices are selected. We're using
		// the  map like a mathematical set. The keys refer to the indexes
		// of the `choices` slice, above.
		selected: nil,
	}, nil
}

// getImagesWithFilter returns a list of docker images that match the given
// filter. If the filter is empty, it returns all images. Generally you will
// want to pass in `nginx/*` to get all images that start with `nginx/`.
func getImagesWithFilter(filter string) (images []image, err error) {
	filters := make(map[string]map[string]bool)
	if filter != "" {
		filters["reference"] = map[string]bool{
			filter: true,
		}
	}

	// Create a new client that handles common environment variables
	// for configuration (DOCKER_HOST, DOCKER_API_VERSION), and does
	// API-version negotiation to allow downgrading the API version
	// when connecting with an older daemon version.
	apiClient, err := client.New(client.FromEnv)
	if err != nil {
		return nil, fmt.Errorf("could not create docker api client: %w", err)
	}
	defer func() {
		err = apiClient.Close()
		if err != nil {
			err = fmt.Errorf("closing github api client: %w", err)
		}
	}()

	ctx, cxl := context.WithTimeout(context.Background(), getImagesTimeout)
	defer cxl()

	// list images
	result, err := apiClient.ImageList(ctx, client.ImageListOptions{
		All:     true,
		Filters: filters,
	})
	if err != nil {
		return nil, fmt.Errorf("could not list images: %w", err)
	}

	images = make([]image, 0, len(result.Items))

	for i, img := range result.Items {
		images[i] = image{
			id:   img.ID,
			tags: img.RepoTags,
			size: humanSizeBinary(img.Size),
		}
	}

	return images, nil
}
