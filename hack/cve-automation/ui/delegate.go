package ui

import (
	"fmt"
	"io"

	"github.com/charmbracelet/bubbles/list"
	tea "github.com/charmbracelet/bubbletea"
)

// SelectableItem is an interface for items that can be selected in a list
type SelectableItem interface {
	list.Item
	GetID() string
	GetTitle() string
}

// SelectDelegate is a custom delegate for rendering list items with selection indicators
type SelectDelegate struct {
	Selected *map[string]struct{}
}

// Render renders a single item in the list with a cursor and checkbox
func (s SelectDelegate) Render(w io.Writer, m list.Model, index int, item list.Item) {
	var title string
	var itemID string

	// Try to cast to SelectableItem
	if selectableItem, ok := item.(SelectableItem); ok {
		title = selectableItem.GetTitle()
		itemID = selectableItem.GetID()
	} else {
		// Fallback to basic list.Item
		title = item.FilterValue()
		itemID = item.FilterValue()
	}

	checked := " "
	if s.Selected != nil {
		if _, ok := (*s.Selected)[itemID]; ok {
			checked = "âœ…"
		}
	}

	cursor := " "
	if index == m.Index() {
		cursor = ">"
	}

	_, _ = fmt.Fprintf(w, "%s %s %s\n", cursor, checked, title)
}

// Height returns the height of each item, which is 2 for this delegate
func (s SelectDelegate) Height() int {
	return 2
}

// Spacing returns the spacing between items, which is 0 for this delegate
func (s SelectDelegate) Spacing() int {
	return 0
}

// Update is not used in this delegate, so it returns nil
func (s SelectDelegate) Update(_ tea.Msg, _ *list.Model) tea.Cmd {
	return nil
}

// NewSelectDelegate creates a new SelectDelegate with the provided selection map
func NewSelectDelegate(sel *map[string]struct{}) SelectDelegate {
	return SelectDelegate{Selected: sel}
}
