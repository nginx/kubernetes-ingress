package ui

import (
	"crypto/rand"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/charmbracelet/bubbles/list"
	"github.com/charmbracelet/lipgloss"
)

// Button styles for confirmation dialogs
var (
	// ActiveButtonStyle is used for the currently selected button
	// (e.g., "Yes" or "No")
	ActiveButtonStyle = lipgloss.NewStyle().
				Foreground(lipgloss.Color("#FFF")).
				Background(lipgloss.Color("#7D56F4")).
				Padding(0, 3).
				Bold(true)

	// InactiveButtonStyle is used for the non-selected button
	InactiveButtonStyle = lipgloss.NewStyle().
				Foreground(lipgloss.Color("#888")).
				Background(lipgloss.Color("#333")).
				Padding(0, 3)

	// DocStyle is a common style for rendering the main content of the TUI
	DocStyle = lipgloss.NewStyle().Margin(1, 2)
)

// HumanSizeBinary returns a human-readable approximation of a size in bytes
func HumanSizeBinary(s int64) string {
	const unit = 1024
	if s < unit {
		return fmt.Sprintf("%d B", s)
	}
	div, exp := int64(unit), 0
	for n := s / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %ciB", float64(s)/float64(div), "KMGTPE"[exp])
}

// GenerateTempDirName creates a unique directory name with the format:
// YYYYMMDD-HHMMSS-<6-random-alphanumeric-chars>
// Returns the full directory name and the random suffix separately.
func GenerateTempDirName() (dirName string, suffix string, err error) {
	timestamp := time.Now().Format("20060102-150405")

	// Generate 6 random alphanumeric characters
	randomBytes := make([]byte, 6)
	if _, err := rand.Read(randomBytes); err != nil {
		return "", "", fmt.Errorf("generating random bytes: %w", err)
	}

	// Use base64 encoding and filter to alphanumeric
	const alphanumeric = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	randomSuffix := make([]byte, 6)
	for i := range randomSuffix {
		randomSuffix[i] = alphanumeric[int(randomBytes[i])%len(alphanumeric)]
	}

	suffix = string(randomSuffix)
	dirName = fmt.Sprintf("%s-%s", timestamp, suffix)
	return dirName, suffix, nil
}

// LoadSarifFilesList loads all SARIF files from the output directory
func LoadSarifFilesList(outputDir string) ([]list.Item, error) {
	pattern := filepath.Join(outputDir, "*.sarif.json")
	files, err := filepath.Glob(pattern)
	if err != nil {
		return nil, fmt.Errorf("finding SARIF files: %w", err)
	}

	items := make([]list.Item, 0, len(files))
	for _, filePath := range files {
		info, err := os.Stat(filePath)
		if err != nil {
			continue
		}

		items = append(items, SarifFile{
			Name: filepath.Base(filePath),
			Path: filePath,
			Size: HumanSizeBinary(info.Size()),
		})
	}

	return items, nil
}

// SarifFile represents a SARIF file that implements the list.Item interface
type SarifFile struct {
	Name string
	Path string
	Size string
}

// FilterValue returns the value used for filtering in the list (the file name)
func (s SarifFile) FilterValue() string {
	return s.Name
}

// Title returns the title displayed in the list (the file name)
func (s SarifFile) Title() string { return s.Name }

// Description returns the description displayed in the list (the file size)
func (s SarifFile) Description() string {
	return s.Size
}

// GetID returns the unique identifier for this SARIF file (its path)
func (s SarifFile) GetID() string {
	return s.Path
}

// GetTitle returns the display title for this SARIF file
func (s SarifFile) GetTitle() string {
	return s.Name
}
