package githubartifacts

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/nginx/kubernetes-ingress/hack/cve-automation/ui"
)

const (
	// DownloadFolder is the subdirectory under baseDirectory where artifacts
	// will be downloaded and extracted. The subdirectory will be created, and
	// user can then decide whether to clean it up after processing.
	DownloadFolder = "downloads"

	// Limit the max file size to download from GitHub to a reasonable size to
	// prevent decompression bomb attacks.
	maxZipBytes = 30 << 20 // 30 MiB compressed
)

// DownloadArtifacts downloads all artifacts to a timestamped directory,
// extracts them, and returns the directory path and random suffix.
// onProgress is called with (artifactName, inProgress, completed) for each artifact state change.
func DownloadArtifacts(artifacts []ArtifactInfo, baseDirectory string, onProgress func(name string, inProgress, completed bool)) (outputDir string, suffix string, err error) {
	// Create temporary directory with timestamp and random suffix
	dirName, randomSuffix, err := ui.GenerateTempDirName()
	if err != nil {
		return "", "", fmt.Errorf("generating temp directory name: %w", err)
	}

	tempDir := filepath.Join(baseDirectory, DownloadFolder, dirName)
	if err := os.MkdirAll(tempDir, 0o750); err != nil {
		return "", "", fmt.Errorf("creating temp directory %s: %w", tempDir, err)
	}

	// Channel for error handling (fail-fast)
	errChan := make(chan error, len(artifacts))
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	var wg sync.WaitGroup

	// Download all artifacts in parallel
	for _, artifact := range artifacts {
		wg.Add(1)
		go func(art ArtifactInfo) {
			defer wg.Done()

			// Check if we should abort due to another goroutine's error
			select {
			case <-ctx.Done():
				return
			default:
			}

			// Notify that download is starting
			if onProgress != nil {
				onProgress(art.Name, true, false)
			}

			err := downloadSingleArtifact(ctx, art, tempDir)
			if err != nil {
				errChan <- err
				cancel() // Signal other goroutines to stop
				return
			}

			// Notify that download is complete
			if onProgress != nil {
				onProgress(art.Name, false, true)
			}
		}(artifact)
	}

	// Wait for all downloads to complete
	wg.Wait()
	close(errChan)

	// Check if any download failed
	if err := <-errChan; err != nil {
		return "", "", fmt.Errorf("downloading artifacts: %w", err)
	}

	// Extract and process all zip files
	for _, artifact := range artifacts {
		zipPath := artifact.Path(tempDir)
		if err := extractAndProcessZip(zipPath, artifact.Name, tempDir); err != nil {
			return "", "", fmt.Errorf("processing zip file %s: %w", zipPath, err)
		}
	}

	return tempDir, randomSuffix, nil
}

// downloadSingleArtifact downloads a single artifact to the specified directory
func downloadSingleArtifact(ctx context.Context, artifact ArtifactInfo, dir string) (err error) {
	u, err := url.Parse(artifact.URL)
	if err != nil {
		return fmt.Errorf("parsing URL %s: %w", artifact.URL, err)
	}

	if u.Scheme != "https" {
		return fmt.Errorf("unexpected scheme: %q, wanted 'https'", u.Scheme)
	}

	host := strings.ToLower(u.Hostname())
	if !strings.HasSuffix(host, ".blob.core.windows.net") {
		return fmt.Errorf("unexpected download host: %q", host)
	}

	path := strings.ToLower(u.Path)
	if !strings.Contains(path, "actions-results") {
		return fmt.Errorf("unexpected download path: %q", path)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", artifact.URL, nil)
	if err != nil {
		return fmt.Errorf("creating request for %s: %w", artifact.Name, err)
	}

	client := &http.Client{
		// Limit the size of the response body to prevent decompression bomb attacks.
		Timeout: 30 * time.Second,
	}

	resp, err := client.Do(req) //gosec:disable G704 -- The download URL comes from a GitHub REST API response, we're validating the URL for both the scheme and the domain, as well as the path, and the client does have a timeout on it.
	if err != nil {
		return fmt.Errorf("downloading %s from %s: %w", artifact.Name, artifact.URL, err)
	}
	defer func() {
		if closeErr := resp.Body.Close(); closeErr != nil && err == nil {
			err = fmt.Errorf("warning: closing response body for %s: %w", artifact.Name, closeErr)
		}
	}()

	// Handle HTTP status codes
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("downloading %s: unexpected response: %d %s", artifact.Name, resp.StatusCode, http.StatusText(resp.StatusCode))
	}

	// Save as zip file
	zipPath := artifact.Path(dir)
	zipFile, err := os.Create(zipPath) //gosec:disable G304 -- the zipPath is generated from a sanitized artifact name and a temp directory name, both of which we control, so this is not a path traversal risk.
	if err != nil {
		return fmt.Errorf("creating zip file %s: %w", zipPath, err)
	}
	defer func() {
		if closeErr := zipFile.Close(); closeErr != nil && err == nil {
			err = fmt.Errorf("closing zip file %s: %w", zipPath, closeErr)
		}
	}()

	if _, err = io.Copy(zipFile, resp.Body); err != nil {
		return fmt.Errorf("writing zip file %s: %w", zipPath, err)
	}

	return nil
}
