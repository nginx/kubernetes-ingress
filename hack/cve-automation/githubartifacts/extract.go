package githubartifacts

import (
	"archive/zip"
	"fmt"
	"io"
	"os"
	"path/filepath"
)

// extractAndProcessZip extracts the SARIF JSON file from a zip archive,
// renames it to match the artifact name, and deletes the zip file.
func extractAndProcessZip(zipPath, artifactName, outputDir string) (err error) {
	// Open the zip file
	r, err := zip.OpenReader(zipPath)
	if err != nil {
		return fmt.Errorf("opening zip file: %w", err)
	}
	defer func() {
		if closeErr := r.Close(); closeErr != nil {
			err = fmt.Errorf("closing zip file: %w; additionally, previous error: %w", closeErr, err)
		}
	}()

	// We expect a single SARIF JSON file in the zip
	if len(r.File) == 0 {
		return fmt.Errorf("zip file is empty")
	}

	if len(r.File) > 1 {
		return fmt.Errorf("zip file contains multiple files, expected only one")
	}

	// Process the first file (should be the only SARIF file)
	f := r.File[0]
	// Open the file inside the zip
	rc, err := f.Open()
	if err != nil {
		return fmt.Errorf("opening file %s in zip: %w", f.Name, err)
	}
	defer func() {
		if closeErr := rc.Close(); closeErr != nil {
			err = fmt.Errorf("closing file %s in zip: %w; additionally, previous error: %w", f.Name, closeErr, err)
		}
	}()

	// Create the output file with the artifact name
	outputPath := filepath.Join(outputDir, filepath.Clean(artifactName)+".sarif.json")
	outFile, err := os.Create(outputPath) //gosec:disable G304 - artifactName is controlled by us, not user input, so this is not a path traversal risk
	if err != nil {
		return fmt.Errorf("creating output file %s: %w", outputPath, err)
	}
	defer func() {
		if closeErr := outFile.Close(); closeErr != nil {
			err = fmt.Errorf("closing output file %s: %w; additionally, previous error: %w", outputPath, closeErr, err)
		}
	}()

	// Copy the content
	if _, err = io.Copy(outFile, io.LimitReader(rc, maxZipBytes)); err != nil {
		return fmt.Errorf("extracting file to %s: %w", outputPath, err)
	}

	// Delete the zip file
	if err = os.Remove(zipPath); err != nil {
		return fmt.Errorf("removing zip file %s: %w", zipPath, err)
	}

	return nil
}
