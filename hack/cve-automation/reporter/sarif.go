package reporter

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"
)

const (
	severityHigh     = "HIGH"
	severityCritical = "CRITICAL"
)

// Report is the root of a sarif json file.
type Report struct {
	Runs []Run `json:"runs"`
}

// Run is a list of runs in a sarif file.
type Run struct {
	Tool Tool `json:"tool"`
}

// Tool is the tool used in a run, which contains a driver with rules.
type Tool struct {
	Driver `json:"driver"`
}

// Driver contains the rules that describe vulnerabilities in a sarif file.
type Driver struct {
	FullName       string `json:"fullName"`
	InformationURI string `json:"informationUri"`
	Name           string `json:"name"`
	Rules          []Rule `json:"rules"`
	Version        string `json:"version"`
}

// Rule lives as :root -> runs[] -> tool -> driver -> rules[]
type Rule struct {
	ID               string           `json:"id"`
	Name             string           `json:"name"`
	ShortDescription ShortDescription `json:"shortDescription"`
	HelpURI          string           `json:"helpUri"`
	Help             Help             `json:"help"`
	Properties       ResultProperties `json:"properties"`
}

// ShortDescription is a short description of a vulnerability in a sarif file.
type ShortDescription struct {
	Text string `json:"text"`
}

// Help is a longer description of a vulnerability in a sarif file, which may
// contain markdown.
type Help struct {
	Text     string `json:"text"`
	Markdown string `json:"markdown"`
}

// ResultProperties contains the properties of a vulnerability in a sarif file,
// such as severity and affected version.
type ResultProperties struct {
	AffectedVersion  string   `json:"affected_version"`
	CvssV3Severity   string   `json:"cvssV3_severity"`
	FixedVersion     string   `json:"fixed_version"`
	Purls            []string `json:"purls"`
	SecuritySeverity string   `json:"security-severity"`
	Tags             []string `json:"tags"`
}

// UniqueVulnerability represents a unique vulnerability across multiple SARIF
// files, aggregating information such as source images, severities, and
// descriptions.
type UniqueVulnerability struct {
	ID                  string
	SourceImages        []string
	NumericalSeverities map[string]string
	TextSeverities      map[string][]string
	Purls               []string
	Description         string
}

// ParseSarifFiles parses SARIF files from a map of file paths and returns unique vulnerabilities
func ParseSarifFiles(paths map[string]struct{}) (map[string]UniqueVulnerability, error) {
	uniqueVulnerabilities := make(map[string]UniqueVulnerability)
	for sarifPath := range paths {
		report, err := parseSarifFile(sarifPath)
		if err != nil {
			return nil, fmt.Errorf("parsing sarif file %s: %w", sarifPath, err)
		}

		imageName := sarifFilePathToFeatures(sarifPath)

		for _, run := range report.Runs {
			for _, rule := range run.Tool.Rules {
				if !severityGate(rule.Properties.Tags) {
					continue
				}

				if _, exists := uniqueVulnerabilities[rule.ID]; !exists {
					uniqueVulnerabilities[rule.ID] = UniqueVulnerability{
						ID:           rule.ID,
						SourceImages: []string{imageName},
						NumericalSeverities: map[string]string{
							imageName: rule.Properties.SecuritySeverity,
						},
						TextSeverities: map[string][]string{
							imageName: rule.Properties.Tags,
						},
						Purls:       rule.Properties.Purls,
						Description: rule.Help.Text,
					}
				} else {
					vuln := uniqueVulnerabilities[rule.ID]
					vuln.SourceImages = append(vuln.SourceImages, imageName)
					vuln.NumericalSeverities[imageName] = rule.Properties.SecuritySeverity
					vuln.TextSeverities[imageName] = append(vuln.TextSeverities[imageName], rule.Properties.Tags...)
					vuln.Purls = append(vuln.Purls, rule.Properties.Purls...)
					uniqueVulnerabilities[rule.ID] = vuln
				}
			}
		}
	}

	return uniqueVulnerabilities, nil
}

func parseSarifFile(sarifFile string) (Report, error) {
	fileBytes, err := os.ReadFile(sarifFile) //gosec:disable G304 - this is a controlled file read, not user input
	if err != nil {
		return Report{}, fmt.Errorf("reading sarif file: %w", err)
	}

	var report Report
	err = json.Unmarshal(fileBytes, &report)
	if err != nil {
		return Report{}, fmt.Errorf("unmarshalling sarif file: %w", err)
	}

	return report, nil
}

func severityGate(severities []string) bool {
	for _, severity := range severities {
		if severity == severityHigh || severity == severityCritical {
			return true
		}
	}

	return false
}

type imageFeature string

const (
	archUbi    imageFeature = "ubi"
	archUbi8   imageFeature = "ubi8"
	archDebian imageFeature = "debian"
	archAlpine imageFeature = "alpine"

	featureNap   imageFeature = "nap"
	featureNapV5 imageFeature = "nap-v5"
	featureDos   imageFeature = "dos"
	featurePlus  imageFeature = "plus"
	featureFips  imageFeature = "fips"
)

// sarifFilePathToFeatures takes a sarif file name and standardizes the output.
func sarifFilePathToFeatures(name string) string {
	dockerParts := strings.Split(name, ":")
	if len(dockerParts) == 2 {
		name = dockerParts[1]
	}

	hasUbi := false
	hasUbi8 := strings.Contains(name, string(archUbi8))
	hasDebian := strings.Contains(name, string(archDebian))
	hasAlpine := strings.Contains(name, string(archAlpine))

	if !hasUbi8 {
		hasUbi = strings.Contains(name, string(archUbi))
	}

	if !exactlyOne(hasUbi8, hasUbi, hasDebian, hasAlpine) {
		return name
	}

	hasNap := false
	hasNapV5 := strings.Contains(name, string(featureNapV5))
	hasDos := strings.Contains(name, string(featureDos))
	hasPlus := strings.Contains(name, string(featurePlus))
	hasFips := strings.Contains(name, string(featureFips))

	if !hasNapV5 {
		hasNap = strings.Contains(name, string(featureNap))
	}

	features := ""
	if hasUbi8 {
		features += string(archUbi8)
	}
	if hasUbi {
		features += string(archUbi)
	}
	if hasDebian {
		features += string(archDebian)
	}
	if hasAlpine {
		features += string(archAlpine)
	}

	if hasNapV5 {
		features += "-" + string(featureNapV5)
	} else if hasNap {
		features += "-" + string(featureNap)
	}
	if hasDos {
		features += "-" + string(featureDos)
	}
	if hasPlus {
		features += "-" + string(featurePlus)
	}
	if hasFips {
		features += "-" + string(featureFips)
	}

	return features
}

func exactlyOne(bs ...bool) bool {
	if len(bs) > 31 {
		return false
	}

	var x uint64
	for i, b := range bs {
		if b {
			x |= 1 << uint(i) //gosec:disable G115 -- i is index of a range over a slice of bools, not user input, so this is not a risk for shift overflow. The slice is also at most 31 elements.
		}
	}
	return x != 0 && (x&(x-1)) == 0
}
