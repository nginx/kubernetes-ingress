package main

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"time"

	"github.com/google/go-github/v82/github"
	"golang.org/x/oauth2"
)

const (
	// The GitHub repository to list artifacts from. This is currently hardcoded
	// to the nginx/kubernetes-ingress repository.
	owner = "nginx"
	repo  = "kubernetes-ingress"

	// To get this, query the repository's workflows using the GitHub API and
	// look for the workflow named "Image Promotion". The ID is included in the
	// response. This is currently hardcoded, but could be made configurable in
	// the future.
	//
	// client.Actions.ListWorkflows(ctx, owner, repo, &github.ListOptions{
	//     Page: 0,
	//     PerPage: 100,
	// })
	imagePromotionWorkflowID = 103448112
)

func getGitHubArtifactURLs(token, branch string) ([]string, error) {
	ctx := context.Background()
	tokenSource := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: token})
	oauth2Client := oauth2.NewClient(ctx, tokenSource)

	client := github.NewClient(oauth2Client)

	// Grab the most recent successful workflow run for the specified branch.
	// This assumes that the workflow is configured to run on pushes to the
	// branch, and that there has been at least one successful run. If there are
	// no successful runs, this will return an error.
	runs, _, err := client.Actions.ListWorkflowRunsByID(ctx, owner, repo, imagePromotionWorkflowID, &github.ListWorkflowRunsOptions{
		Branch:              branch,
		Status:              "success",
		ExcludePullRequests: false,
		ListOptions: github.ListOptions{
			PerPage: 1,
		},
	})
	if err != nil {
		return nil, fmt.Errorf("listing workflow runs for branch %s: %w", branch, err)
	}

	workflowRunID := runs.WorkflowRuns[0].GetID()

	// Grab the artifacts for the workflow run. This assumes that there is at
	// least one artifact, and that the artifact we want is named in a way that
	// we can identify it (e.g. it contains the branch name and "results"). If
	// there are no artifacts, or if the artifact we want cannot be identified,
	// this will return an error.
	artifacts, _, err := client.Actions.ListWorkflowRunArtifacts(ctx, owner, repo, workflowRunID, &github.ListOptions{Page: 0, PerPage: 100})
	if err != nil {
		return nil, fmt.Errorf("listing workflow run artifacts for run %d on branch %s at url %s: %w",
			workflowRunID, branch, runs.WorkflowRuns[0].GetURL(), err)
	}

	resultsRe, err := regexp.Compile(fmt.Sprintf("^%s.+-results$", branch))
	if err != nil {
		return nil, fmt.Errorf("compiling regex for artifact name for branch %s: %w", branch, err)
	}

	downloadURLs := make([]string, 0)

	for _, artifact := range artifacts.Artifacts {
		if resultsRe.MatchString(artifact.GetName()) {
			url, _, err := client.Actions.DownloadArtifact(ctx, owner, repo, artifact.GetID(), 5)
			if err != nil {
				fmt.Printf("getting download URL for artifact ID %d: %v\n", artifact.GetID(), err)
				continue
			}

			downloadURLs = append(downloadURLs, url.String())
		}
	}

	return downloadURLs, nil
}

// getGitHubToken attempts to get a GitHub token by first trying to run the `gh`
// executable, and if that fails, falling back to the GITHUB_TOKEN environment
// variable. This allows for flexibility in how the token is provided, and
// provides a positive escape hatch if the `gh` executable is available and
// properly configured.
//
// Token is needed for any subsequent calls to the GitHub API, such as listing
// artifacts. If neither method works, an error is returned.
func getGitHubToken() (string, error) {
	ctx, cxl := context.WithTimeout(context.Background(), 5*time.Second)
	defer cxl()

	out := bytes.Buffer{}

	cmd := exec.CommandContext(ctx, "gh", "auth", "token")
	cmd.Stdout = &out

	err := cmd.Run()
	if err == nil {
		// This is a positive escape hatch! Return is all is well!
		return strings.TrimSpace(out.String()), nil
	}

	fmt.Println("running the 'gh' executable encountered an issue.\nTrying to get GitHub token using the GITHUB_TOKEN env variable instead.")

	token := os.Getenv("GITHUB_TOKEN")
	if token == "" {
		fmt.Printf("environment variable was empty\n")
		return "", fmt.Errorf("GITHUB_TOKEN environment variable is not set, and previously: %w", err)
	}

	return token, nil
}
