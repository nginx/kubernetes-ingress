package main

import (
	"archive/zip"
	"bytes"
	"context"
	"crypto/rand"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
	"time"

	"github.com/google/go-github/v82/github"
	"golang.org/x/oauth2"
)

const (
	// The GitHub repository to list artifacts from. This is currently hardcoded
	// to the nginx/kubernetes-ingress repository.
	owner = "nginx"
	repo  = "kubernetes-ingress"

	// To get this, query the repository's workflows using the GitHub API and
	// look for the workflow named "Image Promotion". The ID is included in the
	// response. This is currently hardcoded, but could be made configurable in
	// the future.
	//
	// client.Actions.ListWorkflows(ctx, owner, repo, &github.ListOptions{
	//     Page: 0,
	//     PerPage: 100,
	// })
	imagePromotionWorkflowID = 103448112

	downloadFolder = "downloads"

	// Limit the max file size to download from GitHub to a reasonable size to
	// prevent decompression bomb attacks.
	maxZipBytes = 30 << 20 // 30 MiB compressed
)

// artifactInfo holds information about a GitHub artifact
type artifactInfo struct {
	Name string
	URL  string
}

func (a artifactInfo) Path(baseDirectory string) string {
	return filepath.Join(baseDirectory, a.Name+".zip")
}

func getGitHubArtifactURLs(token, branch string) ([]artifactInfo, error) {
	ctx := context.Background()
	tokenSource := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: token})
	oauth2Client := oauth2.NewClient(ctx, tokenSource)

	client := github.NewClient(oauth2Client)

	// Grab the most recent successful workflow run for the specified branch.
	// This assumes that the workflow is configured to run on pushes to the
	// branch, and that there has been at least one successful run. If there are
	// no successful runs, this will return an error.
	runs, _, err := client.Actions.ListWorkflowRunsByID(ctx, owner, repo, imagePromotionWorkflowID, &github.ListWorkflowRunsOptions{
		Branch:              branch,
		Status:              "success",
		ExcludePullRequests: false,
		ListOptions: github.ListOptions{
			PerPage: 1,
		},
	})
	if err != nil {
		return nil, fmt.Errorf("listing workflow runs for branch %s: %w", branch, err)
	}

	workflowRunID := runs.WorkflowRuns[0].GetID()

	// Grab the artifacts for the workflow run. This assumes that there is at
	// least one artifact, and that the artifact we want is named in a way that
	// we can identify it (e.g. it contains the branch name and "results"). If
	// there are no artifacts, or if the artifact we want cannot be identified,
	// this will return an error.
	artifacts, _, err := client.Actions.ListWorkflowRunArtifacts(ctx, owner, repo, workflowRunID, &github.ListOptions{Page: 0, PerPage: 100})
	if err != nil {
		return nil, fmt.Errorf("listing workflow run artifacts for run %d on branch %s at url %s: %w",
			workflowRunID, branch, runs.WorkflowRuns[0].GetURL(), err)
	}

	resultsRe, err := regexp.Compile(fmt.Sprintf("^%s.+-results$", branch))
	if err != nil {
		return nil, fmt.Errorf("compiling regex for artifact name for branch %s: %w", branch, err)
	}

	downloadURLs := make([]artifactInfo, 0)

	for _, artifact := range artifacts.Artifacts {
		if resultsRe.MatchString(artifact.GetName()) {
			url, _, err := client.Actions.DownloadArtifact(ctx, owner, repo, artifact.GetID(), 5)
			if err != nil {
				fmt.Printf("getting download URL for artifact ID %d: %v\n", artifact.GetID(), err)
				continue
			}

			downloadURLs = append(downloadURLs, artifactInfo{
				Name: artifact.GetName(),
				URL:  url.String(),
			})
		}
	}

	return downloadURLs, nil
}

// getGitHubToken attempts to get a GitHub token by first trying to run the `gh`
// executable, and if that fails, falling back to the GITHUB_TOKEN environment
// variable. This allows for flexibility in how the token is provided, and
// provides a positive escape hatch if the `gh` executable is available and
// properly configured.
//
// Token is needed for any subsequent calls to the GitHub API, such as listing
// artifacts. If neither method works, an error is returned.
func getGitHubToken() (string, error) {
	ctx, cxl := context.WithTimeout(context.Background(), 5*time.Second)
	defer cxl()

	out := bytes.Buffer{}

	cmd := exec.CommandContext(ctx, "gh", "auth", "token")
	cmd.Stdout = &out

	err := cmd.Run()
	if err == nil {
		// This is a positive escape hatch! Return is all is well!
		return strings.TrimSpace(out.String()), nil
	}

	fmt.Println("running the 'gh' executable encountered an issue.\nTrying to get GitHub token using the GITHUB_TOKEN env variable instead.")

	token := os.Getenv("GITHUB_TOKEN")
	if token == "" {
		fmt.Printf("environment variable was empty\n")
		return "", fmt.Errorf("GITHUB_TOKEN environment variable is not set, and previously: %w", err)
	}

	return token, nil
}

// generateTempDirName creates a unique directory name with the format:
// YYYYMMDD-HHMMSS-<6-random-alphanumeric-chars>
func generateTempDirName() (string, error) {
	timestamp := time.Now().Format("20060102-150405")

	// Generate 6 random alphanumeric characters
	randomBytes := make([]byte, 6)
	if _, err := rand.Read(randomBytes); err != nil {
		return "", fmt.Errorf("generating random bytes: %w", err)
	}

	// Use base64 encoding and filter to alphanumeric
	const alphanumeric = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	randomSuffix := make([]byte, 6)
	for i := range randomSuffix {
		randomSuffix[i] = alphanumeric[int(randomBytes[i])%len(alphanumeric)]
	}

	return fmt.Sprintf("%s-%s", timestamp, string(randomSuffix)), nil
}

func downloadArtifacts(artifacts []artifactInfo, baseDirectory string) (string, error) {
	// Create temporary directory with timestamp and random suffix
	dirName, err := generateTempDirName()
	if err != nil {
		return "", fmt.Errorf("generating temp directory name: %w", err)
	}

	tempDir := filepath.Join(baseDirectory, downloadFolder, dirName)
	if err := os.MkdirAll(tempDir, 0o640); err != nil {
		return "", fmt.Errorf("creating temp directory %s: %w", tempDir, err)
	}

	// Channel for error handling (fail-fast)
	errChan := make(chan error, len(artifacts))
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	var wg sync.WaitGroup

	// Download all artifacts in parallel
	for _, artifact := range artifacts {
		wg.Add(1)
		go func(art artifactInfo) {
			defer wg.Done()

			// Check if we should abort due to another goroutine's error
			select {
			case <-ctx.Done():
				return
			default:
			}

			err := downloadSingleArtifact(ctx, art, tempDir)
			if err != nil {
				errChan <- err
				cancel() // Signal other goroutines to stop
			}
		}(artifact)
	}

	// Wait for all downloads to complete
	wg.Wait()
	close(errChan)

	// Check if any download failed
	if err := <-errChan; err != nil {
		return "", fmt.Errorf("downloading artifacts: %w", err)
	}

	// Extract and process all zip files
	for _, artifact := range artifacts {
		zipPath := artifact.Path(tempDir)
		if err := extractAndProcessZip(zipPath, artifact.Name, tempDir); err != nil {
			return "", fmt.Errorf("processing zip file %s: %w", zipPath, err)
		}
	}

	return tempDir, nil
}

// downloadSingleArtifact downloads a single artifact to the specified directory
func downloadSingleArtifact(ctx context.Context, artifact artifactInfo, dir string) (err error) {
	req, err := http.NewRequestWithContext(ctx, "GET", artifact.URL, nil)
	if err != nil {
		return fmt.Errorf("creating request for %s: %w", artifact.Name, err)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return fmt.Errorf("downloading %s from %s: %w", artifact.Name, artifact.URL, err)
	}
	defer func() {
		if closeErr := resp.Body.Close(); closeErr != nil {
			err = fmt.Errorf("warning: closing response body for %s: %w", artifact.Name, closeErr)
		}
	}()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("downloading %s: received status %d", artifact.Name, resp.StatusCode)
	}

	// Save as zip file
	zipPath := artifact.Path(dir)
	zipFile, err := os.Create(artifact.Path(dir))
	if err != nil {
		return fmt.Errorf("creating zip file %s: %w", zipPath, err)
	}
	defer func() {
		if err = zipFile.Close(); err != nil {
			err = fmt.Errorf("closing zip file %s: %w", zipPath, err)
		}
	}()

	if _, err = io.Copy(zipFile, resp.Body); err != nil {
		return fmt.Errorf("writing zip file %s: %w", zipPath, err)
	}

	return nil
}

// extractAndProcessZip extracts the SARIF JSON file from a zip archive,
// renames it to match the artifact name, and deletes the zip file.
func extractAndProcessZip(zipPath, artifactName, outputDir string) (err error) {
	// Open the zip file
	r, err := zip.OpenReader(zipPath)
	if err != nil {
		return fmt.Errorf("opening zip file: %w", err)
	}
	defer func() {
		if closeErr := r.Close(); closeErr != nil {
			err = fmt.Errorf("closing zip file: %w; additionally, previous error: %w", closeErr, err)
		}
	}()

	// We expect a single SARIF JSON file in the zip
	if len(r.File) == 0 {
		return fmt.Errorf("zip file is empty")
	}

	if len(r.File) > 1 {
		return fmt.Errorf("zip file contains multiple files, expected only one")
	}

	// Process the first file (should be the only SARIF file)
	f := r.File[0]
	// Open the file inside the zip
	rc, err := f.Open()
	if err != nil {
		return fmt.Errorf("opening file %s in zip: %w", f.Name, err)
	}
	defer func() {
		if closeErr := rc.Close(); closeErr != nil {
			err = fmt.Errorf("closing file %s in zip: %w; additionally, previous error: %w", f.Name, closeErr, err)
		}
	}()

	// Create the output file with the artifact name
	outputPath := filepath.Join(outputDir, artifactName+".sarif.json")
	outFile, err := os.Create(outputPath) //gosec:disable G304 - artifactName is controlled by us, not user input, so this is not a path traversal risk
	if err != nil {
		return fmt.Errorf("creating output file %s: %w", outputPath, err)
	}
	defer func() {
		if closeErr := outFile.Close(); closeErr != nil {
			err = fmt.Errorf("closing output file %s: %w; additionally, previous error: %w", outputPath, closeErr, err)
		}
	}()

	// Copy the content
	if _, err = io.Copy(outFile, io.LimitReader(rc, maxZipBytes)); err != nil {
		return fmt.Errorf("extracting file to %s: %w", outputPath, err)
	}

	// Delete the zip file
	if err = os.Remove(zipPath); err != nil {
		return fmt.Errorf("removing zip file %s: %w", zipPath, err)
	}

	return nil
}
