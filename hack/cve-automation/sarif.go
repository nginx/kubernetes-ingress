package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

type Report struct {
	Runs []Run `json:"runs"`
}

type Run struct {
	Tool Tool `json:"tool"`
}

type Tool struct {
	Driver `json:"driver"`
}

type Driver struct {
	FullName       string `json:"fullName"`
	InformationURI string `json:"informationUri"`
	Name           string `json:"name"`
	Rules          []Rule `json:"rules"`
	Version        string `json:"version"`
}

// Rule lives as :root -> runs[] -> tool -> driver -> rules[]
type Rule struct {
	ID               string           `json:"id"`
	Name             string           `json:"name"`
	ShortDescription ShortDescription `json:"shortDescription"`
	HelpURI          string           `json:"helpUri"`
	Help             Help             `json:"help"`
	Properties       ResultProperties `json:"properties"`
}

type ShortDescription struct {
	Text string `json:"text"`
}

type Help struct {
	Text     string `json:"text"`
	Markdown string `json:"markdown"`
}

type ResultProperties struct {
	AffectedVersion  string   `json:"affected_version"`
	CvssV3Severity   string   `json:"cvssV3_severity"`
	FixedVersion     string   `json:"fixed_version"`
	Purls            []string `json:"purls"`
	SecuritySeverity string   `json:"security-severity"`
	Tags             []string `json:"tags"`
}

type UniqueVulnerability struct {
	ID                  string
	SourceImages        []string
	NumericalSeverities map[string]string
	TextSeverities      map[string][]string
	Purls               []string
	Description         string
}

func parseSarifFiles(baseDirectory, branch string) (map[string]UniqueVulnerability, error) {
	fmt.Printf("Looking for SARIF files in directory: %s\n", baseDirectory)
	fmt.Printf("Using glob pattern %s\n", filepath.Join(baseDirectory, "*.sarif.json"))

	// read in all the .sarif.json files
	sarifFiles, err := filepath.Glob(filepath.Join(baseDirectory, "*.sarif.json"))
	if err != nil {
		return nil, fmt.Errorf("finding sarif files: %w", err)
	}

	// Clean up the file name to get the built image combination.
	// main-ubi-9-plus-nap-goreleaser-waf-results.sarif.json will become
	// ubi-9-plus-nap-waf
	replacer := strings.NewReplacer(
		"-results.sarif.json", "",
		"-goreleaser", "",
		branch+"-", "",
	)

	// parse the sarif files
	uniqueVulnerabilities := make(map[string]UniqueVulnerability)
	for _, sarifFile := range sarifFiles {
		report, err := parseSarifFile(sarifFile)
		if err != nil {
			return nil, fmt.Errorf("parsing sarif file %s: %w", sarifFile, err)
		}

		archName := replacer.Replace(filepath.Base(sarifFile))

		for _, run := range report.Runs {
			for _, rule := range run.Tool.Rules {
				if _, exists := uniqueVulnerabilities[rule.ID]; !exists {
					fmt.Printf(" -> Adding new vulnerability: %s from file: %s\n", rule.ID, sarifFile)
					uniqueVulnerabilities[rule.ID] = UniqueVulnerability{
						ID:           rule.ID,
						SourceImages: []string{archName},
						NumericalSeverities: map[string]string{
							archName: rule.Properties.SecuritySeverity,
						},
						TextSeverities: map[string][]string{
							archName: rule.Properties.Tags,
						},
						Purls:       rule.Properties.Purls,
						Description: rule.Help.Text,
					}
				} else {
					vuln := uniqueVulnerabilities[rule.ID]
					vuln.SourceImages = append(vuln.SourceImages, archName)
					vuln.NumericalSeverities[archName] = rule.Properties.SecuritySeverity
					vuln.TextSeverities[archName] = append(vuln.TextSeverities[archName], rule.Properties.Tags...)
					vuln.Purls = append(vuln.Purls, rule.Properties.Purls...)
					uniqueVulnerabilities[rule.ID] = vuln
				}
			}
		}

		// 	vulnerabilities, err := parseSarifFile(sarifFile)
		// 	if err != nil {
		// 		return nil, fmt.Errorf("parsing sarif file %s: %w", sarifFile, err)
		// 	}
		// 	for _, vuln := range vulnerabilities {
		// 		uniqueVulnerabilities[vuln] = struct{}{}
		// 	}
	}

	return uniqueVulnerabilities, nil
}

func parseSarifFile(sarifFile string) (Report, error) {
	// read the sarif file into bytes
	fileBytes, err := os.ReadFile(sarifFile) //gosec:disable G304 - this is a controlled file read, not user input
	if err != nil {
		return Report{}, fmt.Errorf("reading sarif file: %w", err)
	}

	var report Report
	err = json.Unmarshal(fileBytes, &report)
	if err != nil {
		return Report{}, fmt.Errorf("unmarshalling sarif file: %w", err)
	}

	fmt.Printf("Parsed sarif file: %s\n", sarifFile)

	return report, nil
}
