package dockerscan

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/charmbracelet/bubbles/list"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/nginx/kubernetes-ingress/hack/cve-automation/reporter"
	"github.com/nginx/kubernetes-ingress/hack/cve-automation/ui"
)

const (
	downloadFolder = "downloads"
)

// sarifProgressMsg is sent as progress updates during SARIF generation
type sarifProgressMsg struct {
	message    string
	ch         chan tea.Msg
	imageTitle string  // The image being processed
	completed  bool    // Whether this image is done
	progress   float64 // Overall progress (0.0 to 1.0)
}

// sarifGenerationCompleteMsg is sent when SARIF generation completes
type sarifGenerationCompleteMsg struct {
	outputDir    string
	randomSuffix string
	err          error
}

// parseCompleteMsg is sent when parsing and rendering completes
type parseCompleteMsg struct {
	reportPath string
	err        error
}

var metaReplacer = strings.NewReplacer(
	// token separators / whitespace
	" ", "-",
	"\t", "-",
	"\n", "-",
	"/", "-",
	// quoting / escaping
	`"`, "",
	`'`, "",
	"`", "",
	// parameter / variable expansion
	"$", "",
	"{", "",
	"}", "",
	// command substitution
	"&", "",
	";", "",
	"(", "",
	")", "",
	// globbing (pathname expansion parameters
	`?`, "",
	`*`, "",
	"[", "",
	"]", "",
	// redirection operators
	">", "",
	"<", "",
	`|`, "",
	// background job
	"!", "",
	"^", "",
)

// generateSarifFiles runs docker scout cves on each selected image in parallel and saves the SARIF output
// Note: docker scout is a CLI plugin and not available through the Docker SDK, so we use exec.Command
func generateSarifFiles(selected map[string]struct{}, allItems []list.Item) tea.Cmd {
	return func() tea.Msg {
		// Create output directory with timestamp
		dirName, suffix, err := ui.GenerateTempDirName()
		if err != nil {
			return sarifGenerationCompleteMsg{err: fmt.Errorf("generating temp directory name: %w", err)}
		}

		outputDir := filepath.Join(downloadFolder, dirName)
		if err := os.MkdirAll(outputDir, 0o750); err != nil {
			return sarifGenerationCompleteMsg{err: fmt.Errorf("creating output directory %s: %w", outputDir, err)}
		}

		// Use a channel for progress messages
		msgChan := make(chan tea.Msg, 100)

		go func() {
			defer close(msgChan)

			msgChan <- sarifProgressMsg{
				message:  fmt.Sprintf("ðŸ“ Created directory: %s", outputDir),
				ch:       msgChan,
				progress: 0.0,
			}

			// Count total selected images
			totalImages := len(selected)
			var completedCount atomic.Int32

			// Collect selected images
			var selectedImages []dockerImage
			for _, item := range allItems {
				img := item.(dockerImage)
				if _, isSelected := selected[img.id]; isSelected {
					selectedImages = append(selectedImages, img)
				}
			}

			// Use WaitGroup to track completion of all goroutines
			var wg sync.WaitGroup
			var firstError error
			var errorMu sync.Mutex

			// Generate SARIF files for each selected image in parallel
			for _, img := range selectedImages {
				wg.Add(1)
				go func(image dockerImage) {
					defer wg.Done()

					// Check if we already have an error
					errorMu.Lock()
					if firstError != nil {
						errorMu.Unlock()
						return
					}
					errorMu.Unlock()

					// Sanitize the image title to create a valid filename
					filename := strings.ReplaceAll(image.title, "/", "-")
					filename = strings.ReplaceAll(filename, ":", "-")
					outputPath := filepath.Join(outputDir, filename+".sarif.json")

					// Send "scanning" message
					msgChan <- sarifProgressMsg{
						message:    fmt.Sprintf("ðŸ” Scanning %s...", image.title),
						ch:         msgChan,
						imageTitle: image.title,
						completed:  false,
						progress:   float64(completedCount.Load()) / float64(totalImages),
					}

					ctx, cxl := context.WithTimeout(context.Background(), 20*time.Second)

					sanitizedTitle := metaReplacer.Replace(image.title)

					// Run docker scout cves command
					cmd := exec.CommandContext(ctx, "docker", "scout", "cves", "--format", "sarif", "--output", outputPath, sanitizedTitle) //gosec:disable G204 -- no part of this path is user-controlled. The outputPath is generated from a sanitized image title and a temp directory name, both of which we control, and image.title is also sanitized and controlled by docker.
					if err := cmd.Run(); err != nil {
						errorMu.Lock()
						if firstError == nil {
							firstError = fmt.Errorf("running docker scout for %s: %w", image.title, err)
						}
						errorMu.Unlock()
						cxl()
						return
					}

					// Increment completed count
					completed := completedCount.Add(1)

					// Send "completed" message
					msgChan <- sarifProgressMsg{
						message:    fmt.Sprintf("âœ… Generated: %s.sarif.json", filename),
						ch:         msgChan,
						imageTitle: image.title,
						completed:  true,
						progress:   float64(completed) / float64(totalImages),
					}

					cxl()
				}(img)
			}

			// Wait for all goroutines to complete
			wg.Wait()

			// Check if there was an error
			if firstError != nil {
				msgChan <- sarifGenerationCompleteMsg{
					outputDir: outputDir,
					err:       firstError,
				}
				return
			}

			msgChan <- sarifGenerationCompleteMsg{outputDir: outputDir, randomSuffix: suffix, err: nil}
		}()

		return waitForMessages(msgChan)
	}
}

// parseAndRenderReport parses selected SARIF files and generates a markdown report
func parseAndRenderReport(outputDir string, suffix string, selectedSarifs map[string]struct{}) tea.Cmd {
	return func() tea.Msg {
		vulns, err := reporter.ParseSarifFiles(selectedSarifs)
		if err != nil {
			return parseCompleteMsg{err: fmt.Errorf("parsing SARIF files: %w", err)}
		}

		// Get the base directory (project root) to find templates and write reports
		baseDir := filepath.Dir(filepath.Dir(outputDir))

		// Render markdown report
		reportPath, err := reporter.RenderMarkdown(vulns, baseDir, suffix)
		if err != nil {
			return parseCompleteMsg{err: fmt.Errorf("rendering report: %w", err)}
		}

		return parseCompleteMsg{reportPath: reportPath, err: nil}
	}
}

// waitForMessages reads from the channel and returns the first message
func waitForMessages(ch chan tea.Msg) tea.Msg {
	return <-ch
}

// continueWaitingForMessages is a Cmd that continues reading from the channel
func continueWaitingForMessages(ch chan tea.Msg) tea.Cmd {
	return func() tea.Msg {
		msg, ok := <-ch
		if !ok {
			// Channel closed, we're done
			return nil
		}
		return msg
	}
}
